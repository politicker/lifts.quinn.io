// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createLiftSetLog = `-- name: CreateLiftSetLog :exec
INSERT INTO lift_set_log (workout_name, workout_duration, exercise_name, set_order, weight, reps, distance, seconds,
                          notes, workout_notes, rpe, logged_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT (workout_name, exercise_name, set_order, logged_at) DO NOTHING
`

type CreateLiftSetLogParams struct {
	WorkoutName     string
	WorkoutDuration string
	ExerciseName    string
	SetOrder        int32
	Weight          float64
	Reps            float64
	Distance        float64
	Seconds         float64
	Notes           sql.NullString
	WorkoutNotes    sql.NullString
	Rpe             sql.NullString
	LoggedAt        time.Time
}

func (q *Queries) CreateLiftSetLog(ctx context.Context, arg CreateLiftSetLogParams) error {
	_, err := q.db.ExecContext(ctx, createLiftSetLog,
		arg.WorkoutName,
		arg.WorkoutDuration,
		arg.ExerciseName,
		arg.SetOrder,
		arg.Weight,
		arg.Reps,
		arg.Distance,
		arg.Seconds,
		arg.Notes,
		arg.WorkoutNotes,
		arg.Rpe,
		arg.LoggedAt,
	)
	return err
}

const get1RMHistory = `-- name: Get1RMHistory :many
WITH OrderedSets AS (SELECT DISTINCT ON (logged_at) logged_at,
                                                    weight,
                                                    reps,
                                                    (weight * reps * 0.0333 + weight)::float AS estimated_1rm
                     FROM lift_set_log
                     WHERE lower(exercise_name) = lower($1)
                     ORDER BY logged_at DESC, estimated_1rm DESC
                     LIMIT 11)
SELECT estimated_1rm, logged_at, (round(weight)::text || ' x ' || reps::text) as set_text
FROM OrderedSets
ORDER BY logged_at ASC
`

type Get1RMHistoryRow struct {
	Estimated1rm float64
	LoggedAt     time.Time
	SetText      sql.NullString
}

func (q *Queries) Get1RMHistory(ctx context.Context, lower string) ([]Get1RMHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, get1RMHistory, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Get1RMHistoryRow
	for rows.Next() {
		var i Get1RMHistoryRow
		if err := rows.Scan(&i.Estimated1rm, &i.LoggedAt, &i.SetText); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestSet = `-- name: GetBestSet :one
SELECT (round(weight)::text || ' x ' || reps::text) AS set_text,
       weight,
       reps,
       logged_at,
       (weight * reps * 0.0333 + weight)            as estimated_1rm
FROM lift_set_log
WHERE LOWER(exercise_name) = LOWER($1)
ORDER BY estimated_1rm DESC,
         logged_at DESC
LIMIT 1
`

type GetBestSetRow struct {
	SetText      sql.NullString
	Weight       float64
	Reps         float64
	LoggedAt     time.Time
	Estimated1rm float64
}

func (q *Queries) GetBestSet(ctx context.Context, lower string) (GetBestSetRow, error) {
	row := q.db.QueryRowContext(ctx, getBestSet, lower)
	var i GetBestSetRow
	err := row.Scan(
		&i.SetText,
		&i.Weight,
		&i.Reps,
		&i.LoggedAt,
		&i.Estimated1rm,
	)
	return i, err
}
