// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createLiftSetLog = `-- name: CreateLiftSetLog :exec
INSERT INTO lift_set_log (workout_name, workout_duration, exercise_name, set_order, weight, reps, distance, seconds,
                          notes, workout_notes, rpe, logged_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT (workout_name, exercise_name, set_order, logged_at) DO NOTHING
`

type CreateLiftSetLogParams struct {
	WorkoutName     string
	WorkoutDuration string
	ExerciseName    string
	SetOrder        int32
	Weight          float64
	Reps            float64
	Distance        float64
	Seconds         float64
	Notes           sql.NullString
	WorkoutNotes    sql.NullString
	Rpe             sql.NullString
	LoggedAt        time.Time
}

func (q *Queries) CreateLiftSetLog(ctx context.Context, arg CreateLiftSetLogParams) error {
	_, err := q.db.ExecContext(ctx, createLiftSetLog,
		arg.WorkoutName,
		arg.WorkoutDuration,
		arg.ExerciseName,
		arg.SetOrder,
		arg.Weight,
		arg.Reps,
		arg.Distance,
		arg.Seconds,
		arg.Notes,
		arg.WorkoutNotes,
		arg.Rpe,
		arg.LoggedAt,
	)
	return err
}

const get1RMHistory = `-- name: Get1RMHistory :many
WITH OrderedSets AS (
    SELECT DISTINCT ON (logged_at) logged_at, (weight * reps * 0.0333 + weight)::float AS estimated_1rm
    FROM lift_set_log
    WHERE lower(exercise_name) = lower($1)
    ORDER BY logged_at DESC, estimated_1rm DESC
    LIMIT 11
)
SELECT estimated_1rm
FROM OrderedSets
ORDER BY logged_at ASC
`

func (q *Queries) Get1RMHistory(ctx context.Context, lower string) ([]float64, error) {
	rows, err := q.db.QueryContext(ctx, get1RMHistory, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []float64
	for rows.Next() {
		var estimated_1rm float64
		if err := rows.Scan(&estimated_1rm); err != nil {
			return nil, err
		}
		items = append(items, estimated_1rm)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestSet = `-- name: GetBestSet :one
SELECT (round(weight)::text || ' x ' || reps::text) AS best_set
FROM lift_set_log
WHERE LOWER(exercise_name) = LOWER($1)
ORDER BY (weight * reps * 0.0333 + weight) DESC,
         logged_at DESC
LIMIT 1
`

func (q *Queries) GetBestSet(ctx context.Context, lower string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getBestSet, lower)
	var best_set sql.NullString
	err := row.Scan(&best_set)
	return best_set, err
}
